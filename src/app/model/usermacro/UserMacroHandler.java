package app.model.usermacro;

import java.util.LinkedList;
import java.util.List;
import java.util.stream.Collectors;

import app.model.encodes.Rot13Encode;
import app.model.myenums.UserCommandsEnums;

/**
 * This class is responsible for creating and archiving {@link UserMacro} with
 * the help of a {@link UserCommandsFactory}.
 *
 */
public class UserMacroHandler {

	private LinkedList<UserCommandsEnums> macrosAdded;
	private LinkedList<UserMacro> createdMacros;
	private UserMacro lastMacro;
	private boolean speakCommand;
	private boolean rotEncoded;
	private boolean atbashEcoded;
	private UserCommandsFactory factory;

	{
		speakCommand = false;
		rotEncoded = false;
		atbashEcoded = false;
	}

	public UserMacroHandler(UserCommandsFactory factory) {

		this.factory = factory;
		macrosAdded = new LinkedList<>();
		createdMacros = new LinkedList<>();
		lastMacro = new UserMacro();

	}

	/**
	 * Adds a command to the {@link UserMacro} based on the
	 * {@link UserCommandsEnums} provided.
	 * 
	 * @param commandEnum The UserCommandEnum to specify which command to add.
	 */
	public void add(UserCommandsEnums commandEnum) {

		if (UserCommandsEnums.isSpeakCommand(commandEnum)) {
			speakCommand = true;
		} else if (commandEnum.equals(UserCommandsEnums.AtBash)) {
			atbashEcoded = true;
		} else if (commandEnum.equals(UserCommandsEnums.Rot13)) {
			rotEncoded = true;
		}

		lastMacro.addCommand(factory.getCommand(commandEnum), commandEnum);
		macrosAdded.add(commandEnum);
	}

	/**
	 * This method returns the last {@link UserMacro} created after giving it a name
	 * via the {@link UserMacro#setName(String) setName(String)} method.
	 * 
	 * @param name The name of the UserMacro.
	 * @return An instance of UserMacro.
	 */
	public UserMacro generateMacro(String name) {
		if (name.contentEquals("")) {
			name = "Untitled";
		}
		lastMacro.setName(name);
		createdMacros.add(lastMacro);
		return lastMacro;
	}

	
	
	/**
	 * 
	 * @return A {@link UserMacro} instance. This UserMacro was the last macro this
	 *         UserMacroHandler was editing.
	 */
	public UserMacro getLastMacro() {
		return lastMacro;
	}

	
	
	/**
	 * Clears the archived {@link UserMacro} .
	 */
	public void clear() {
		macrosAdded.clear();
		resetBooleans();
		lastMacro = new UserMacro();
	}

	
	
	/**
	 * 
	 * @return true if one of the commands contained in the {@link UserMacro} has a
	 *         command that narrated the document. False otherwise.
	 */
	public boolean hasSpeakCommand() {
		return speakCommand;
	}

	
	
	/**
	 * 
	 * @return true if the {@link UserMacro} contains a command that encodes the
	 *         text according to {@link Rot13Encode}.
	 */
	public boolean hasRotEncode() {
		return rotEncoded;
	}

	
	
	/**
	 * 
	 * @return true if the {@link UserMacro} contains a command that encodes the
	 *         text according to {@link AtbashEcode}.
	 */
	public boolean hasAtbashEcode() {
		return atbashEcoded;
	}

	
	
	/**
	 * This method returns a list of {@link UserCommandsEnums} representing the
	 * commands that are added to the {@link UserMacro}.
	 * 
	 * @return a list of {@link UserCommandsEnums}.
	 *         <p>
	 *         This list is backed by the original list and any changed will appear
	 *         on the original one.
	 */
	public List<UserCommandsEnums> getCommandsAddedList() {
		return macrosAdded;
	}
	
	
	

	/**
	 * This commands returns a list of Strings with the names of the
	 * {@link UserMacro} already archived. The names are generated via the
	 * {@link UserMacro#toString() toString()} method which in turn fetches the name
	 * the UserMacro has set to.
	 * 
	 * @return a deep copy of a List of Strings representing the names of the
	 *         macros.
	 */
	public List<String> getMacrosCreatedList() {

		return createdMacros.stream().map((um) -> um.toString()).collect(Collectors.toList());

	}

	
	
	/**
	 * This method returns an archived {@link UserMacro}. THe UserMacro to be
	 * returned is specified by an int.
	 * <p>
	 * UserMacros generated by this instance are added to a list. So the fist macro
	 * is in the 0 position the second in 1 and so on.
	 * 
	 * @param pos The position the UserMacro.
	 * @return A UserMacro if the int passed as parameter is withing bounds. Null
	 *         otherwise.
	 */
	public UserMacro getMacro(int pos) {
		try {
			return createdMacros.get(pos);
		} catch (IndexOutOfBoundsException e) {
			return null;
		}

	}

	private void resetBooleans() {
		speakCommand = false;
		rotEncoded = false;
		atbashEcoded = false;
	}

}
